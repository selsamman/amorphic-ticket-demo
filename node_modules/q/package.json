{
  "name": "q",
  "version": "0.9.3",
  "description": "A library for promises (CommonJS/Promises/A,B,D)",
  "homepage": "https://github.com/kriskowal/q",
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com",
    "url": "https://github.com/kriskowal"
  },
  "keywords": [
    "q",
    "promise",
    "promises",
    "promises-a",
    "promises-a-plus",
    "deferred",
    "future",
    "async",
    "flow control",
    "fluent",
    "browser",
    "node"
  ],
  "contributors": [
    {
      "name": "Kris Kowal",
      "email": "kris@cixar.com",
      "url": "https://github.com/kriskowal"
    },
    {
      "name": "Irakli Gozalishvili",
      "email": "rfobic@gmail.com",
      "url": "http://jeditoolkit.com"
    },
    {
      "name": "Domenic Denicola",
      "email": "domenic@domenicdenicola.com",
      "url": "http://domenicdenicola.com"
    }
  ],
  "bugs": {
    "mail": "kris@cixar.com",
    "url": "http://github.com/kriskowal/q/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/kriskowal/q/raw/master/LICENSE"
    }
  ],
  "main": "q.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/kriskowal/q.git"
  },
  "engines": {
    "node": ">=0.6.0",
    "teleport": ">=0.2.0"
  },
  "dependencies": {},
  "devDependencies": {
    "jshint": ">=1.1.0",
    "cover": "*",
    "jasmine-node": "1.2.2",
    "opener": "*",
    "promises-aplus-tests": "1.x"
  },
  "scripts": {
    "test": "jasmine-node spec && promises-aplus-tests spec/aplus-adapter",
    "test-browser": "opener spec/q-spec.html",
    "lint": "jshint q.js",
    "cover": "cover run node_modules/jasmine-node/bin/jasmine-node spec && cover report html && opener cover_html/index.html"
  },
  "overlay": {
    "teleport": {
      "dependencies": {
        "system": ">=0.0.4"
      }
    }
  },
  "directories": {
    "test": "./spec"
  },
  "readme": "[![Build Status](https://secure.travis-ci.org/kriskowal/q.png?branch=master)](http://travis-ci.org/kriskowal/q)\r\n\r\n<a href=\"http://promises-aplus.github.com/promises-spec\">\r\n    <img src=\"http://promises-aplus.github.com/promises-spec/assets/logo-small.png\"\r\n         align=\"right\" alt=\"Promises/A+ logo\" />\r\n</a>\r\n\r\nIf a function cannot return a value or throw an exception without\r\nblocking, it can return a promise instead.  A promise is an object\r\nthat represents the return value or the thrown exception that the\r\nfunction may eventually provide.  A promise can also be used as a\r\nproxy for a [remote object][Q-Connection] to overcome latency.\r\n\r\n[Q-Connection]: https://github.com/kriskowal/q-connection\r\n\r\nOn the first pass, promises can mitigate the “[Pyramid of\r\nDoom][POD]”: the situation where code marches to the right faster\r\nthan it marches forward.\r\n\r\n[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\r\n\r\n```javascript\r\nstep1(function (value1) {\r\n    step2(value1, function(value2) {\r\n        step3(value2, function(value3) {\r\n            step4(value3, function(value4) {\r\n                // Do something with value4\r\n            });\r\n        });\r\n    });\r\n});\r\n```\r\n\r\nWith a promise library, you can flatten the pyramid.\r\n\r\n```javascript\r\nQ.fcall(step1)\r\n.then(step2)\r\n.then(step3)\r\n.then(step4)\r\n.then(function (value4) {\r\n    // Do something with value4\r\n}, function (error) {\r\n    // Handle any error from step1 through step4\r\n})\r\n.done();\r\n```\r\n\r\nWith this approach, you also get implicit error propagation,\r\njust like ``try``, ``catch``, and ``finally``.  An error in\r\n``step1`` will flow all the way to ``step5``, where it’s\r\ncaught and handled.\r\n\r\nThe callback approach is called an “inversion of control”.\r\nA function that accepts a callback instead of a return value\r\nis saying, “Don’t call me, I’ll call you.”.  Promises\r\n[un-invert][IOC] the inversion, cleanly separating the input\r\narguments from control flow arguments.  This simplifies the\r\nuse and creation of API’s, particularly variadic,\r\nrest and spread arguments.\r\n\r\n[IOC]: http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript\r\n\r\n\r\n## Getting Started\r\n\r\nThe Q module can be loaded as:\r\n\r\n-   A ``<script>`` tag (creating a ``Q`` global variable): ~3 KB minified and\r\n    gzipped.\r\n-   A Node.js and CommonJS module, available in [npm](https://npmjs.org/) as\r\n    the [q](https://npmjs.org/package/q) package\r\n-   An AMD module\r\n-   A [component](https://github.com/component/component) as ``microjs/q``\r\n-   Using [bower](http://twitter.github.com/bower/) as ``microjs/q``\r\n-   Using [NuGet](http://nuget.org/) as [Q](https://nuget.org/packages/q)\r\n\r\nQ can exchange promises with jQuery, Dojo, When.js, WinJS, and more.\r\nAdditionally, there are many libraries that produce and consume Q promises for\r\neverything from file system/database access or RPC to templating. For a list of\r\nsome of the more popular ones, see [Libraries][].\r\n\r\nPlease join the Q-Continuum [mailing list](https://groups.google.com/forum/#!forum/q-continuum).\r\n\r\n[Libraries]: https://github.com/kriskowal/q/wiki/Libraries\r\n\r\n\r\n## Tutorial\r\n\r\nPromises have a ``then`` method, which you can use to get the eventual\r\nreturn value (fulfillment) or thrown exception (rejection).\r\n\r\n```javascript\r\npromiseMeSomething()\r\n.then(function (value) {\r\n}, function (reason) {\r\n});\r\n```\r\n\r\nIf ``promiseMeSomething`` returns a promise that gets fulfilled later\r\nwith a return value, the first function (the fulfillment handler) will be\r\ncalled with the value.  However, if the ``promiseMeSomething`` function\r\ngets rejected later by a thrown exception, the second function (the\r\nrejection handler) will be called with the exception.\r\n\r\nNote that resolution of a promise is always asynchronous: that is, the\r\nfulfillment or rejection handler will always be called in the next turn of the\r\nevent loop (i.e. `process.nextTick` in Node). This gives you a nice\r\nguarantee when mentally tracing the flow of your code, namely that\r\n``then`` will always return before either handler is executed.\r\n\r\n\r\n### Propagation\r\n\r\nThe ``then`` method returns a promise, which in this example, I’m\r\nassigning to ``outputPromise``.\r\n\r\n```javascript\r\nvar outputPromise = getInputPromise()\r\n.then(function (input) {\r\n}, function (reason) {\r\n});\r\n```\r\n\r\nThe ``outputPromise`` variable becomes a new promise for the return\r\nvalue of either handler.  Since a function can only either return a\r\nvalue or throw an exception, only one handler will ever be called and it\r\nwill be responsible for resolving ``outputPromise``.\r\n\r\n-   If you return a value in a handler, ``outputPromise`` will get\r\n    fulfilled.\r\n\r\n-   If you throw an exception in a handler, ``outputPromise`` will get\r\n    rejected.\r\n\r\n-   If you return a **promise** in a handler, ``outputPromise`` will\r\n    “become” that promise.  Being able to become a new promise is useful\r\n    for managing delays, combining results, or recovering from errors.\r\n\r\nIf the ``getInputPromise()`` promise gets rejected and you omit the\r\nrejection handler, the **error** will go to ``outputPromise``:\r\n\r\n```javascript\r\nvar outputPromise = getInputPromise()\r\n.then(function (value) {\r\n});\r\n```\r\n\r\nIf the input promise gets fulfilled and you omit the fulfillment handler, the\r\n**value** will go to ``outputPromise``:\r\n\r\n```javascript\r\nvar outputPromise = getInputPromise()\r\n.then(null, function (error) {\r\n});\r\n```\r\n\r\nQ promises provide a ``fail`` shorthand for ``then`` when you are only\r\ninterested in handling the error:\r\n\r\n```javascript\r\nvar outputPromise = getInputPromise()\r\n.fail(function (error) {\r\n});\r\n```\r\n\r\nIf you are writing JavaScript for modern engines only or using\r\nCoffeeScript, you may use `catch` instead of `fail`.\r\n\r\nPromises also have a ``fin`` function that is like a ``finally`` clause.\r\nThe final handler gets called, with no arguments, when the promise\r\nreturned by ``getInputPromise()`` either returns a value or throws an\r\nerror.  The value returned or error thrown by ``getInputPromise()``\r\npasses directly to ``outputPromise`` unless the final handler fails, and\r\nmay be delayed if the final handler returns a promise.\r\n\r\n```javascript\r\nvar outputPromise = getInputPromise()\r\n.fin(function () {\r\n    // close files, database connections, stop servers, conclude tests\r\n});\r\n```\r\n\r\n-   If the handler returns a value, the value is ignored\r\n-   If the handler throws an error, the error passes to ``outputPromise``\r\n-   If the handler returns a promise, ``outputPromise`` gets postponed.  The\r\n    eventual value or error has the same effect as an immediate return\r\n    value or thrown error: a value would be ignored, an error would be\r\n    forwarded.\r\n\r\nIf you are writing JavaScript for modern engines only or using\r\nCoffeeScript, you may use `finally` instead of `fin`.\r\n\r\n### Chaining\r\n\r\nThere are two ways to chain promises.  You can chain promises either\r\ninside or outside handlers.  The next two examples are equivalent.\r\n\r\n```javascript\r\nreturn getUsername()\r\n.then(function (username) {\r\n    return getUser(username)\r\n    .then(function (user) {\r\n        // if we get here without an error,\r\n        // the value returned here\r\n        // or the exception thrown here\r\n        // resolves the promise returned\r\n        // by the first line\r\n    })\r\n});\r\n```\r\n\r\n```javascript\r\nreturn getUsername()\r\n.then(function (username) {\r\n    return getUser(username);\r\n})\r\n.then(function (user) {\r\n    // if we get here without an error,\r\n    // the value returned here\r\n    // or the exception thrown here\r\n    // resolves the promise returned\r\n    // by the first line\r\n});\r\n```\r\n\r\nThe only difference is nesting.  It’s useful to nest handlers if you\r\nneed to capture multiple input values in your closure.\r\n\r\n```javascript\r\nfunction authenticate() {\r\n    return getUsername()\r\n    .then(function (username) {\r\n        return getUser(username);\r\n    })\r\n    // chained because we will not need the user name in the next event\r\n    .then(function (user) {\r\n        return getPassword()\r\n        // nested because we need both user and password next\r\n        .then(function (password) {\r\n            if (user.passwordHash !== hash(password)) {\r\n                throw new Error(\"Can't authenticate\");\r\n            }\r\n        });\r\n    });\r\n}\r\n```\r\n\r\n\r\n### Combination\r\n\r\nYou can turn an array of promises into a promise for the whole,\r\nfulfilled array using ``all``.\r\n\r\n```javascript\r\nreturn Q.all([\r\n    eventualAdd(2, 2),\r\n    eventualAdd(10, 20)\r\n]);\r\n```\r\n\r\nIf you have a promise for an array, you can use ``spread`` as a\r\nreplacement for ``then``.  The ``spread`` function “spreads” the\r\nvalues over the arguments of the fulfillment handler.  The rejection handler\r\nwill get called at the first sign of failure.  That is, whichever of\r\nthe recived promises fails first gets handled by the rejection handler.\r\n\r\n```javascript\r\nfunction eventualAdd(a, b) {\r\n    return Q.spread([a, b], function (a, b) {\r\n        return a + b;\r\n    })\r\n}\r\n```\r\n\r\nBut ``spread`` calls ``all`` initially, so you can skip it in chains.\r\n\r\n```javascript\r\nreturn getUsername()\r\n.then(function (username) {\r\n    return [username, getUser(username)];\r\n})\r\n.spread(function (username, user) {\r\n});\r\n```\r\n\r\nThe ``all`` function returns a promise for an array of values.  When this \r\npromise is fulfilled, the array contains the fulfillment values of the original\r\npromises, in the same order as those promises.  If one of the given promises\r\nis rejected, the returned promise is immediately rejected, not waiting for the\r\nrest of the batch.  If you want to wait for all of the promises to either be\r\nfulfilled or rejected, you can use ``allResolved``.\r\n\r\n```javascript\r\nQ.allResolved(promises)\r\n.then(function (promises) {\r\n    promises.forEach(function (promise) {\r\n        if (promise.isFulfilled()) {\r\n            var value = promise.valueOf();\r\n        } else {\r\n            var exception = promise.valueOf().exception;\r\n        }\r\n    })\r\n});\r\n```\r\n\r\n\r\n### Sequences\r\n\r\nIf you have a number of promise-producing functions that need\r\nto be run sequentially, you can of course do so manually:\r\n\r\n```javascript\r\nreturn foo(initialVal).then(bar).then(baz).then(qux);\r\n```\r\n\r\nHowever, if you want to run a dynamically constructed sequence of\r\nfunctions, you'll want something like this:\r\n\r\n```javascript\r\nvar funcs = [foo, bar, baz, qux];\r\n\r\nvar result = Q.resolve(initialVal);\r\nfuncs.forEach(function (f) {\r\n    result = result.then(f);\r\n});\r\nreturn result;\r\n```\r\n\r\nYou can make this slightly more compact using `reduce`:\r\n\r\n```javascript\r\nreturn funcs.reduce(function (soFar, f) {\r\n    return soFar.then(f);\r\n}, Q.resolve(initialVal));\r\n```\r\n\r\nOr, you could use th ultra-compact version:\r\n\r\n```javascript\r\nreturn funcs.reduce(Q.when, Q());\r\n```\r\n\r\n### Handling Errors\r\n\r\nOne sometimes-unintuive aspect of promises is that if you throw an\r\nexception in the fulfillment handler, it will not be be caught by the error\r\nhandler.\r\n\r\n```javascript\r\nreturn foo()\r\n.then(function (value) {\r\n    throw new Error(\"Can't bar.\");\r\n}, function (error) {\r\n    // We only get here if \"foo\" fails\r\n});\r\n```\r\n\r\nTo see why this is, consider the parallel between promises and\r\n``try``/``catch``. We are ``try``-ing to execute ``foo()``: the error\r\nhandler represents a ``catch`` for ``foo()``, while the fulfillment handler\r\nrepresents code that happens *after* the ``try``/``catch`` block.\r\nThat code then needs its own ``try``/``catch`` block.\r\n\r\nIn terms of promises, this means chaining your rejection handler:\r\n\r\n```javascript\r\nreturn foo()\r\n.then(function (value) {\r\n    throw new Error(\"Can't bar.\");\r\n})\r\n.fail(function (error) {\r\n    // We get here with either foo's error or bar's error\r\n});\r\n```\r\n\r\n### Progress Notification\r\n\r\nIt's possible for promises to report their progress, e.g. for tasks that take a\r\nlong time like a file upload. Not all promises will implement progress\r\nnotifications, but for those that do, you can consume the progress values using\r\na third parameter to ``then``:\r\n\r\n```javascript\r\nreturn uploadFile()\r\n.then(function () {\r\n    // Success uploading the file\r\n}, function (err) {\r\n    // There was an error, and we get the reason for error\r\n}, function (progress) {\r\n    // We get notified of the upload's progress as it is executed\r\n});\r\n```\r\n\r\nLike `fail`, Q also provides a shorthand for progress callbacks\r\ncalled `progress`:\r\n\r\n```javascript\r\nreturn uploadFile().progress(function (progress) {\r\n    // We get notified of the upload's progress\r\n});\r\n```\r\n\r\n### The End\r\n\r\nWhen you get to the end of a chain of promises, you should either\r\nreturn the last promise or end the chain.  Since handlers catch\r\nerrors, it’s an unfortunate pattern that the exceptions can go\r\nunobserved.\r\n\r\nSo, either return it,\r\n\r\n```javascript\r\nreturn foo()\r\n.then(function () {\r\n    return \"bar\";\r\n});\r\n```\r\n\r\nOr, end it.\r\n\r\n```javascript\r\nfoo()\r\n.then(function () {\r\n    return \"bar\";\r\n})\r\n.done();\r\n```\r\n\r\nEnding a promise chain makes sure that, if an error doesn’t get\r\nhandled before the end, it will get rethrown and reported.\r\n\r\nThis is a stopgap. We are exploring ways to make unhandled errors\r\nvisible without any explicit handling.\r\n\r\n\r\n### The Beginning\r\n\r\nEverything above assumes you get a promise from somewhere else.  This\r\nis the common case.  Every once in a while, you will need to create a\r\npromise from scratch.\r\n\r\n#### Using ``Q.fcall``\r\n\r\nYou can create a promise from a value using ``Q.fcall``.  This returns a\r\npromise for 10.\r\n\r\n```javascript\r\nreturn Q.fcall(function () {\r\n    return 10;\r\n});\r\n```\r\n\r\nYou can also use ``fcall`` to get a promise for an exception.\r\n\r\n```javascript\r\nreturn Q.fcall(function () {\r\n    throw new Error(\"Can't do it\");\r\n});\r\n```\r\n\r\nAs the name implies, ``fcall`` can call functions, or even promised\r\nfunctions.  This uses the ``eventualAdd`` function above to add two\r\nnumbers.\r\n\r\n```javascript\r\nreturn Q.fcall(eventualAdd, 2, 2);\r\n```\r\n\r\n\r\n#### Using Deferreds\r\n\r\nIf you have to interface with asynchronous functions that are callback-based\r\ninstead of promise-based, Q provides a few shortcuts (like ``Q.nfcall`` and\r\nfriends). But much of the time, the solution will be to use *deferreds*.\r\n\r\n```javascript\r\nvar deferred = Q.defer();\r\nFS.readFile(\"foo.txt\", \"utf-8\", function (error, text) {\r\n    if (error) {\r\n        deferred.reject(new Error(error));\r\n    } else {\r\n        deferred.resolve(text);\r\n    }\r\n});\r\nreturn deferred.promise;\r\n```\r\n\r\nNote that a deferred can be resolved with a value or a promise.  The\r\n``reject`` function is a shorthand for resolving with a rejected\r\npromise.\r\n\r\n```javascript\r\n// this:\r\ndeferred.reject(new Error(\"Can't do it\"));\r\n\r\n// is shorthand for:\r\nvar rejection = Q.fcall(function () {\r\n    throw new Error(\"Can't do it\");\r\n});\r\ndeferred.resolve(rejection);\r\n```\r\n\r\nThis is a simplified implementation of ``Q.delay``.\r\n\r\n```javascript\r\nfunction delay(ms) {\r\n    var deferred = Q.defer();\r\n    setTimeout(deferred.resolve, ms);\r\n    return deferred.promise;\r\n}\r\n```\r\n\r\nThis is a simplified implementation of ``Q.timeout``\r\n\r\n```javascript\r\nfunction timeout(promise, ms) {\r\n    var deferred = Q.defer();\r\n    Q.when(promise, deferred.resolve);\r\n    Q.when(delay(ms), function () {\r\n        deferred.reject(new Error(\"Timed out\"));\r\n    });\r\n    return deferred.promise;\r\n}\r\n```\r\n\r\nFinally, you can send a progress notification to the promise with\r\n``deferred.notify``.\r\n\r\nFor illustration, this is a wrapper for XML HTTP requests in the browser. Note\r\nthat a more [thorough][XHR] implementation would be in order in practice.\r\n\r\n[XHR]: https://github.com/montagejs/mr/blob/71e8df99bb4f0584985accd6f2801ef3015b9763/browser.js#L29-L73\r\n\r\n```javascript\r\nfunction requestOkText(url) {\r\n    var request = new XMLHttpRequest();\r\n    var deferred = Q.defer();\r\n\r\n    request.open(\"GET\", url, true);\r\n    request.onload = onload;\r\n    request.onerror = onerror;\r\n    request.onprogress = onprogress;\r\n    request.send();\r\n\r\n    function onload() {\r\n        if (request.status === 200) {\r\n            deferred.resolve(request.responseText);\r\n        } else {\r\n            onerror();\r\n        }\r\n    }\r\n\r\n    function onerror() {\r\n        deferred.reject(\"Can't XHR \" + JSON.stringify(url));\r\n    }\r\n\r\n    function onprogress(event) {\r\n        deferred.notify(event.loaded / event.total);\r\n    }\r\n\r\n    return deferred.promise;\r\n}\r\n```\r\n\r\n\r\n### The Middle\r\n\r\nIf you are using a function that may return a promise, but just might\r\nreturn a value if it doesn’t need to defer, you can use the “static”\r\nmethods of the Q library.\r\n\r\nThe ``when`` function is the static equivalent for ``then``.\r\n\r\n```javascript\r\nreturn Q.when(valueOrPromise, function (value) {\r\n}, function (error) {\r\n});\r\n```\r\n\r\nAll of the other methods on a promise have static analogs with the\r\nsame name.\r\n\r\nThe following are equivalent:\r\n\r\n```javascript\r\nreturn Q.all([a, b]);\r\n```\r\n\r\n```javascript\r\nreturn Q.fcall(function () {\r\n    return [a, b];\r\n})\r\n.all();\r\n```\r\n\r\nWhen working with promises provided by other libraries, you should\r\nconvert it to a Q promise.  Not all promise libraries make the same\r\nguarantees as Q and certainly don’t provide all of the same methods.\r\nMost libraries only provide a partially functional ``then`` method.\r\nThis thankfully is all we need to turn them into vibrant Q promises.\r\n\r\n```javascript\r\nreturn Q.when($.ajax(...))\r\n.then(function () {\r\n});\r\n```\r\n\r\nIf there is any chance that the promise you receive is not a Q promise\r\nas provided by your library, you should wrap it using a Q function.\r\nYou can even use ``Q.invoke`` as a shorthand.\r\n\r\n```javascript\r\nreturn Q.invoke($, 'ajax', ...)\r\n.then(function () {\r\n});\r\n```\r\n\r\n\r\n### Over the Wire\r\n\r\nA promise can serve as a proxy for another object, even a remote\r\nobject.  There are methods that allow you to optimistically manipulate\r\nproperties or call functions.  All of these interactions return\r\npromises, so they can be chained.\r\n\r\n```\r\ndirect manipulation         using a promise as a proxy\r\n--------------------------  -------------------------------\r\nvalue.foo                   promise.get(\"foo\")\r\nvalue.foo = value           promise.put(\"foo\", value)\r\ndelete value.foo            promise.del(\"foo\")\r\nvalue.foo(...args)          promise.post(\"foo\", [args])\r\nvalue.foo(...args)          promise.invoke(\"foo\", ...args)\r\nvalue(...args)              promise.fapply([args])\r\nvalue(...args)              promise.fcall(...args)\r\n```\r\n\r\nIf the promise is a proxy for a remote object, you can shave\r\nround-trips by using these functions instead of ``then``.  To take\r\nadvantage of promises for remote objects, check out [Q-Connection][].\r\n\r\n[Q-Connection]: https://github.com/kriskowal/q-connection\r\n\r\nEven in the case of non-remote objects, these methods can be used as\r\nshorthand for particularly-simple fulfillment handlers. For example, you\r\ncan replace\r\n\r\n```javascript\r\nreturn Q.fcall(function () {\r\n    return [{ foo: \"bar\" }, { foo: \"baz\" }];\r\n})\r\n.then(function (value) {\r\n    return value[0].foo;\r\n});\r\n```\r\n\r\nwith\r\n\r\n```javascript\r\nreturn Q.fcall(function () {\r\n    return [{ foo: \"bar\" }, { foo: \"baz\" }];\r\n})\r\n.get(0)\r\n.get(\"foo\");\r\n```\r\n\r\n\r\n### Adapting Node\r\n\r\nThere is a ``makeNodeResolver`` method on deferreds that is handy for\r\nthe NodeJS callback pattern.\r\n\r\n```javascript\r\nvar deferred = Q.defer();\r\nFS.readFile(\"foo.txt\", \"utf-8\", deferred.makeNodeResolver());\r\nreturn deferred.promise;\r\n```\r\n\r\nAnd there are ``Q.nfcall`` and ``Q.ninvoke`` for even shorter\r\nexpression.\r\n\r\n```javascript\r\nreturn Q.nfcall(FS.readFile, \"foo.txt\", \"utf-8\");\r\n```\r\n\r\n```javascript\r\nreturn Q.ninvoke(FS, \"readFile\", \"foo.txt\", \"utf-8\");\r\n```\r\n\r\nThere is also a ``Q.nfbind`` function that that creates a reusable\r\nwrapper.\r\n\r\n```javascript\r\nvar readFile = Q.nfbind(FS.readFile);\r\nreturn readFile(\"foo.txt\", \"utf-8\");\r\n```\r\n\r\nNote that, since promises are always resolved in the next turn of the\r\nevent loop, working with streams [can be tricky][streams]. The\r\nessential problem is that, since Node does not buffer input, it is\r\nnecessary to attach your ``\"data\"`` event listeners immediately,\r\nbefore this next turn comes around. There are a variety of solutions\r\nto this problem, and even some hope that in future versions of Node it\r\nwill [be ameliorated][streamsnext].\r\n\r\n[streams]: https://groups.google.com/d/topic/q-continuum/xr8znxc_K5E/discussion\r\n[streamsnext]: http://maxogden.com/node-streams#streams.next\r\n\r\n### Long Stack Traces\r\n\r\nQ comes with *experimental* support for “long stack traces,” wherein the `stack`\r\nproperty of `Error` rejection reasons is rewritten to be traced along\r\nasynchronous jumps instead of stopping at the most recent one. As an example:\r\n\r\n```js\r\nfunction theDepthsOfMyProgram() {\r\n  Q.delay(100).done(function explode() {\r\n    throw new Error(\"boo!\");\r\n  });\r\n}\r\n\r\ntheDepthsOfMyProgram();\r\n```\r\n\r\ngives a strack trace of:\r\n\r\n```\r\nError: boo!\r\n    at explode (/path/to/test.js:3:11)\r\nFrom previous event:\r\n    at theDepthsOfMyProgram (/path/to/test.js:2:16)\r\n    at Object.<anonymous> (/path/to/test.js:7:1)\r\n```\r\n\r\nNote how you can see the the function that triggered the async operation in the\r\nstack trace! This is very helpful for debugging, as otherwise you end up getting\r\nonly the first line, plus a bunch of Q internals, with no sign of where the\r\noperation started.\r\n\r\nThis feature comes with some caveats, however. First, it does not (<em>yet!</em>)\r\nstitch together multiple asynchronous steps. You only get the one immediately\r\nprior to the operation that throws. Secondly, it comes with a performance\r\npenalty, and so if you are using Q to create many promises in a\r\nperformance-critical situation, you will probably want to turn it off.\r\n\r\nTo turn it off, set\r\n\r\n```js\r\nQ.longStackJumpLimit = 0;\r\n```\r\n\r\nThen you stack traces will revert to their usual unhelpful selves:\r\n\r\n```\r\nError: boo!\r\n    at explode (/path/to/test.js:3:11)\r\n    at _fulfilled (/path/to/test.js:q:54)\r\n    at resolvedValue.promiseDispatch.done (/path/to/q.js:823:30)\r\n    at makePromise.promise.promiseDispatch (/path/to/q.js:496:13)\r\n    at pending (/path/to/q.js:397:39)\r\n    at process.startup.processNextTick.process._tickCallback (node.js:244:9)\r\n```\r\n\r\n## Reference\r\n\r\nA method-by-method [Q API reference][reference] is available on the wiki.\r\n\r\n[reference]: https://github.com/kriskowal/q/wiki/API-Reference\r\n\r\n## More Examples\r\n\r\nA growing [examples gallery][examples] is available on the wiki, showing how Q\r\ncan be used to make everything better. From XHR to database access to accessing\r\nthe Flickr API, Q is there for you.\r\n\r\n[examples]: https://github.com/kriskowal/q/wiki/Examples-Gallery\r\n\r\n## Tests\r\n\r\nYou can view the results of the Q test suite [in your browser][tests]!\r\n\r\n[tests]: https://rawgithub.com/kriskowal/q/master/spec/q-spec.html\r\n\r\n---\r\n\r\nCopyright 2009-2012 Kristopher Michael Kowal\r\nMIT License (enclosed)\r\n\r\n",
  "_id": "q@0.9.3",
  "_from": "q"
}
